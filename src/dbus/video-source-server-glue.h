
/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__video_source_server_glue_h__ADAPTOR_MARSHAL_H
#define __dbusxx__video_source_server_glue_h__ADAPTOR_MARSHAL_H

#include <dbus-c++/dbus.h>
#include <cassert>

namespace ipcam {
namespace Media {

class VideoSource_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    VideoSource_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource")
    {
        bind_property(Resolution, "s", true, true);
        bind_property(Framerate, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod VideoSource_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod VideoSource_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty VideoSource_adaptor_properties[] = 
        {
            { "Resolution", "s", true, true },
            { "Framerate", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface VideoSource_adaptor_interface = 
        {
            "ipcam.Media.VideoSource",
            VideoSource_adaptor_methods,
            VideoSource_adaptor_signals,
            VideoSource_adaptor_properties
        };
        return &VideoSource_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< std::string > Resolution;
    ::DBus::PropertyAdaptor< uint32_t > Framerate;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } 
namespace ipcam {
namespace Media {
namespace VideoSource {

class Imaging_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Imaging_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging")
    {
        bind_property(Mirror, "b", true, true);
        bind_property(Flip, "b", true, true);
        bind_property(Brightness, "u", true, true);
        bind_property(Contrast, "u", true, true);
        bind_property(Chroma, "u", true, true);
        bind_property(Saturation, "u", true, true);
        bind_property(Sharpness, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod Imaging_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Imaging_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Imaging_adaptor_properties[] = 
        {
            { "Mirror", "b", true, true },
            { "Flip", "b", true, true },
            { "Brightness", "u", true, true },
            { "Contrast", "u", true, true },
            { "Chroma", "u", true, true },
            { "Saturation", "u", true, true },
            { "Sharpness", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Imaging_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging",
            Imaging_adaptor_methods,
            Imaging_adaptor_signals,
            Imaging_adaptor_properties
        };
        return &Imaging_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< bool > Mirror;
    ::DBus::PropertyAdaptor< bool > Flip;
    ::DBus::PropertyAdaptor< uint32_t > Brightness;
    ::DBus::PropertyAdaptor< uint32_t > Contrast;
    ::DBus::PropertyAdaptor< uint32_t > Chroma;
    ::DBus::PropertyAdaptor< uint32_t > Saturation;
    ::DBus::PropertyAdaptor< uint32_t > Sharpness;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class AntiFlicker_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    AntiFlicker_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.AntiFlicker")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Frequency, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod AntiFlicker_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod AntiFlicker_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty AntiFlicker_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Frequency", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface AntiFlicker_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.AntiFlicker",
            AntiFlicker_adaptor_methods,
            AntiFlicker_adaptor_signals,
            AntiFlicker_adaptor_properties
        };
        return &AntiFlicker_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< uint32_t > Frequency;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class BacklightCompensation_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    BacklightCompensation_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.BacklightCompensation")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Level, "i", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod BacklightCompensation_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod BacklightCompensation_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty BacklightCompensation_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Level", "i", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface BacklightCompensation_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.BacklightCompensation",
            BacklightCompensation_adaptor_methods,
            BacklightCompensation_adaptor_signals,
            BacklightCompensation_adaptor_properties
        };
        return &BacklightCompensation_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< int32_t > Level;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class Focus_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Focus_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.Focus")
    {
        bind_property(AutoFocusMode, "u", true, true);
        bind_property(DefaultSpeed, "u", true, true);
        bind_property(NearLimit, "u", true, true);
        bind_property(FarLimit, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod Focus_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Focus_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Focus_adaptor_properties[] = 
        {
            { "AutoFocusMode", "u", true, true },
            { "DefaultSpeed", "u", true, true },
            { "NearLimit", "u", true, true },
            { "FarLimit", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Focus_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.Focus",
            Focus_adaptor_methods,
            Focus_adaptor_signals,
            Focus_adaptor_properties
        };
        return &Focus_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > AutoFocusMode;
    ::DBus::PropertyAdaptor< uint32_t > DefaultSpeed;
    ::DBus::PropertyAdaptor< uint32_t > NearLimit;
    ::DBus::PropertyAdaptor< uint32_t > FarLimit;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class Exposure_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Exposure_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.Exposure")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Priority, "u", true, true);
        bind_property(MinExposureTime, "u", true, true);
        bind_property(MaxExposureTime, "u", true, true);
        bind_property(MinGain, "u", true, true);
        bind_property(MaxGain, "u", true, true);
        bind_property(MinIris, "u", true, true);
        bind_property(MaxIris, "u", true, true);
        bind_property(ExposureTime, "u", true, true);
        bind_property(Compensation, "u", true, true);
        bind_property(Gain, "u", true, true);
        bind_property(Iris, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod Exposure_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Exposure_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Exposure_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Priority", "u", true, true },
            { "MinExposureTime", "u", true, true },
            { "MaxExposureTime", "u", true, true },
            { "MinGain", "u", true, true },
            { "MaxGain", "u", true, true },
            { "MinIris", "u", true, true },
            { "MaxIris", "u", true, true },
            { "ExposureTime", "u", true, true },
            { "Compensation", "u", true, true },
            { "Gain", "u", true, true },
            { "Iris", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Exposure_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.Exposure",
            Exposure_adaptor_methods,
            Exposure_adaptor_signals,
            Exposure_adaptor_properties
        };
        return &Exposure_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< uint32_t > Priority;
    ::DBus::PropertyAdaptor< uint32_t > MinExposureTime;
    ::DBus::PropertyAdaptor< uint32_t > MaxExposureTime;
    ::DBus::PropertyAdaptor< uint32_t > MinGain;
    ::DBus::PropertyAdaptor< uint32_t > MaxGain;
    ::DBus::PropertyAdaptor< uint32_t > MinIris;
    ::DBus::PropertyAdaptor< uint32_t > MaxIris;
    ::DBus::PropertyAdaptor< uint32_t > ExposureTime;
    ::DBus::PropertyAdaptor< uint32_t > Compensation;
    ::DBus::PropertyAdaptor< uint32_t > Gain;
    ::DBus::PropertyAdaptor< uint32_t > Iris;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class WhiteBalance_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    WhiteBalance_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.WhiteBalance")
    {
        bind_property(Mode, "u", true, true);
        bind_property(CrGain, "u", true, true);
        bind_property(CbGain, "u", true, true);
        bind_property(RGain, "u", true, true);
        bind_property(GGain, "u", true, true);
        bind_property(BGain, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod WhiteBalance_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod WhiteBalance_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty WhiteBalance_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "CrGain", "u", true, true },
            { "CbGain", "u", true, true },
            { "RGain", "u", true, true },
            { "GGain", "u", true, true },
            { "BGain", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface WhiteBalance_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.WhiteBalance",
            WhiteBalance_adaptor_methods,
            WhiteBalance_adaptor_signals,
            WhiteBalance_adaptor_properties
        };
        return &WhiteBalance_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< uint32_t > CrGain;
    ::DBus::PropertyAdaptor< uint32_t > CbGain;
    ::DBus::PropertyAdaptor< uint32_t > RGain;
    ::DBus::PropertyAdaptor< uint32_t > GGain;
    ::DBus::PropertyAdaptor< uint32_t > BGain;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class WideDynamicRange_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    WideDynamicRange_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.WideDynamicRange")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Level, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod WideDynamicRange_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod WideDynamicRange_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty WideDynamicRange_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Level", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface WideDynamicRange_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.WideDynamicRange",
            WideDynamicRange_adaptor_methods,
            WideDynamicRange_adaptor_signals,
            WideDynamicRange_adaptor_properties
        };
        return &WideDynamicRange_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< uint32_t > Level;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class LDC_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    LDC_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.LDC")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Ratio, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod LDC_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod LDC_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty LDC_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Ratio", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface LDC_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.LDC",
            LDC_adaptor_methods,
            LDC_adaptor_signals,
            LDC_adaptor_properties
        };
        return &LDC_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< uint32_t > Ratio;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class Gamma_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Gamma_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.Gamma")
    {
        bind_property(CurveData, "au", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod Gamma_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Gamma_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Gamma_adaptor_properties[] = 
        {
            { "CurveData", "au", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Gamma_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.Gamma",
            Gamma_adaptor_methods,
            Gamma_adaptor_signals,
            Gamma_adaptor_properties
        };
        return &Gamma_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< std::vector< uint32_t > > CurveData;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class NoiseReduction_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    NoiseReduction_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.NoiseReduction")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Level, "u", true, true);
        bind_property(ParamTable, "a(uii)", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod NoiseReduction_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod NoiseReduction_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty NoiseReduction_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Level", "u", true, true },
            { "ParamTable", "a(uii)", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface NoiseReduction_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.NoiseReduction",
            NoiseReduction_adaptor_methods,
            NoiseReduction_adaptor_signals,
            NoiseReduction_adaptor_properties
        };
        return &NoiseReduction_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< uint32_t > Level;
    ::DBus::PropertyAdaptor< std::vector< ::DBus::Struct< uint32_t, int32_t, int32_t > > > ParamTable;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace ipcam {
namespace Media {
namespace VideoSource {
namespace Imaging {

class IrCutFilter_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    IrCutFilter_adaptor()
    : ::DBus::InterfaceAdaptor("ipcam.Media.VideoSource.Imaging.IrCutFilter")
    {
        bind_property(Mode, "u", true, true);
        bind_property(Threshold, "i", true, true);
        bind_property(Hysteresis, "u", true, true);
        bind_property(Brightness, "u", true, true);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod IrCutFilter_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod IrCutFilter_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty IrCutFilter_adaptor_properties[] = 
        {
            { "Mode", "u", true, true },
            { "Threshold", "i", true, true },
            { "Hysteresis", "u", true, true },
            { "Brightness", "u", true, true },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface IrCutFilter_adaptor_interface = 
        {
            "ipcam.Media.VideoSource.Imaging.IrCutFilter",
            IrCutFilter_adaptor_methods,
            IrCutFilter_adaptor_signals,
            IrCutFilter_adaptor_properties
        };
        return &IrCutFilter_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< uint32_t > Mode;
    ::DBus::PropertyAdaptor< int32_t > Threshold;
    ::DBus::PropertyAdaptor< uint32_t > Hysteresis;
    ::DBus::PropertyAdaptor< uint32_t > Brightness;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
#endif //__dbusxx__video_source_server_glue_h__ADAPTOR_MARSHAL_H
